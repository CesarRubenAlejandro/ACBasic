/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 * Autors: Angela Romo, Cesar Rodriguez
 */
options
{
  static = true;
}

PARSER_BEGIN(ACBasic)
import Data.*;
import java.util.Stack;
public class ACBasic
{
  private static DirectorioProcedimientos dirProcedimientos;
  private static String procedimientoActual;
  private static Stack <Integer> pilaOperadores;
  private static Stack <Integer> pilaOperandos;
  private static Stack <Integer> pilaTipos;
  private static CuboSemantico cuboSemantico;
  
  public static void main(String args []) throws ParseException {
    ACBasic parser = new ACBasic(System.in);
	pilaOperadores = new Stack<Integer>();
	pilaOperandos = new Stack<Integer>();
	pilaTipos = new Stack<Integer>();
	cuboSemantico = new CuboSemantico();

    System.out.println("Reading from standard input...");
    try
    {
     parser.prog();
     System.out.println("OK.");
     for (String keyActual: dirProcedimientos.getProcedimientos().keySet()){
          System.out.println("---------------------------");
          Procedimiento actual = dirProcedimientos.getProcedimientos().get(keyActual);
          System.out.print(actual.getNombreProcedimiento()+ ": ");
          System.out.println(actual.getTipoProcedimiento());
          for (String keyVariable : actual.getVariables().keySet()) {			Variable varActual = actual.getVariables().get(keyVariable);
			System.out.print(varActual.getNombreVariable() + ": ");
			System.out.print(varActual.getTipoVariable() + ": ");
			System.out.println(varActual.getDireccionVariable());
          }
      }
          
      } catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
      }
    }
  

  static void errorHandler(int type, String detail) {
    switch (type){
      case 1:
        System.out.println("Error: Procedimiento repetido:" + detail);
		System.exit(0);
      	break;
	  case 2:
        System.out.println("Error: Variable repetida:" + detail);
		System.exit(0);
      	break;
      case 3:
        System.out.println("Error: Parametro repetido:" + detail);
		System.exit(0);
      	break;
          }  }
  
}

PARSER_END(ACBasic)

SKIP : { " " | "\r" | "\t" | "\n" }
TOKEN: { < PROGRAM : "program" > }
TOKEN: { < VAR : "var" > }
TOKEN: { < FUNC : "func" > }
TOKEN: { < MAIN : "main" > }
TOKEN: { < VOID : "void" > }

TOKEN: { < INT : "int" > }
TOKEN: { < CHAR : "char" > }
TOKEN: { < FLOAT : "float" > }
TOKEN: { < BOOL : "bool" > }
TOKEN: { < STRING : "string" > }
TOKEN: { < ARRAY : "array" > }

TOKEN: { < PRINT : "print" > }
TOKEN: { < READ : "read" > }
TOKEN: { < WHILE : "while" > }
TOKEN: { < TRUE : "true" > }
TOKEN: { < FALSE : "false" > }
TOKEN: { < IF : "if" > }
TOKEN: { < ELIF : "elif" > }
TOKEN: { < ELSE : "else" > }

TOKEN: { < AMP : "&" > }
TOKEN: { < RETURN : "return" > }

TOKEN: { < PYC : ";" > }
TOKEN: { < COMA : "," > }


TOKEN: { < LLAIZQ : "{" > }
TOKEN: { < LLADER : "}" > }
TOKEN: { < CORIZQ : "[" > }
TOKEN: { < CORDER : "]" > }

TOKEN: { < IGUAL : "=" > }
TOKEN: { < PARIZQ : "(" > }
TOKEN: { < PARDER : ")" > }
TOKEN: { < MAYOR : ">" > }
TOKEN: { < MENOR : "<" > }
TOKEN: { < MENORIG : "<=" > }
TOKEN: { < MAYORIG : ">=" > }
TOKEN: { < IGUALIG : "==" > }
TOKEN: { < DIFERENTE : "!=" > }
TOKEN: { < NEGACION : "!" > }
TOKEN: { < AND : "&&" > }
TOKEN: { < OR : "||" > }

TOKEN: { < MAS : "+" > }
TOKEN: { < MENOS : "-" > }
TOKEN: { < POR : "*" > }
TOKEN: { < ENTRE : "/" > }

TOKEN: { < ID : < LETTER >(("_")? (< LETTER >|< DIGIT >))* > }
TOKEN: { < CTEI : (<DIGIT>)+> }
TOKEN: { < CTEF : (<DIGIT>)+ "." (<DIGIT>)+ > }
TOKEN: { < CTESTR : "\"" (< DIGIT >|< LETTER >| < CARACTER >)* "\"" > }
TOKEN: { < CTECHAR : "'" (< DIGIT >|< LETTER >| < CARACTER >)? "'" > }

TOKEN :
{
  <#DIGIT: ["0"-"9"]>
| <#LETTER: ["a"-"z", "A"-"Z"]>
| < #CARACTER : ["¡" , "!" , "@" , "#" , "$" , "%" , "&" , "/" , "\\" , "(" , ")" , "=" ,"¿" , "?" , "-" , "_"
	,"+" ,"*","{","}" ,"[" ,"]" ,":" ,";" ,"." ,"," ,">","<" ,"|" ," "]>
}


void prog() :
{Token idPrograma;}
{
  < PROGRAM >  {
    dirProcedimientos = new DirectorioProcedimientos();  }
   idPrograma =  <ID >
   {
     	// guardar el id del procedimiento actual
		procedimientoActual = idPrograma.toString();
		// crear un objeto procedimiento auxiliar para guardar info del procedimiento program
		Procedimiento programProc = new Procedimiento();
		programProc.setNombreProcedimiento(idPrograma.toString());
		programProc.setTipoProcedimiento(Codigos.PROGRAM);
		// guardar el procedimiento program en el directorio de procedimientos
		if (!dirProcedimientos.agregarProcedimiento(programProc)) {
		  // si ya existe un procedimiento con ese nombre, reportar error
		  errorHandler(1,idPrograma.toString());		}
   }
   <PYC > [vars()] (func())* main()
}

int tipo():
{}
{
  < INT > {return Codigos.INT;}
  | < FLOAT > {return Codigos.FLOAT;}
  | < CHAR > {return Codigos.CHAR;}
  | < STRING > {return Codigos.STRING;}
  | < BOOL > {return Codigos.BOOL;}
}

void cte():
{}
{
  < CTEI > | < CTEF > | < TRUE > | < FALSE > | < CTESTR > | < CTECHAR >
}

void defarr():
{}
{
  < CORIZQ > cte() (< COMA > cte())* < CORDER >
}

void vars():
{}
{
  < VAR >  {
    // crear tabla de variables para el procedimiento actual
    dirProcedimientos.getProcedimientos().get(procedimientoActual).crearTablaDeVariables();  }
   vars1() < PYC > (vars1() < PYC >)*
}

void vars1():
{}
{
  vars2() | vars3()
}

void vars2():
{int tipoVariable; Token nombreVariable;}
{
  tipoVariable = tipo() nombreVariable=< ID >
  {
    // asignar el tipo de scope de la variable
    
    String scopeVar = "local";
    if (procedimientoActual.equals("program")) {	  // unicamente si el procedimiento actual es de tipo program, el scope es global
      scopeVar = "global";
   	}
   	// crear objeto variable y darlo de alta en directorio de variables del procedimiento actual
    Variable varAuxiliar = new Variable(nombreVariable.toString(), tipoVariable, scopeVar);
    if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(varAuxiliar)){
	  // si ya existe una variable en este directorio con el mismo nombre, reportar error
      errorHandler(2,nombreVariable.toString());    }  }[<IGUAL > cte()]
  (< COMA > nombreVariable=<ID >
	{
   	// crear objeto variable y darlo de alta en directorio de variables del procedimiento actual
	    varAuxiliar = new Variable(nombreVariable.toString(), tipoVariable, scopeVar);
	    if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(varAuxiliar)) {
		    // si ya existe una variable en este directorio con el mismo nombre, reportar error
      		errorHandler(2,nombreVariable.toString());
    	}
    }
    [<IGUAL > cte()] )* 
}

void vars3():
{int tipoArreglo; Token nombreArreglo;}
{
  < ARRAY >
  {
    // crear objeto variable
    Variable auxArreglo = new Variable();
  }
  tipoArreglo = tipo()  {
    // guardar el tipo de variable
    auxArreglo.setTipoVariable(tipoArreglo);  }
  nombreArreglo = < ID >
  {
    // guardar el nombre de la variable
    auxArreglo.setNombreVariable(nombreArreglo.toString());

    // definir el scope de la variable
    String scope = "local";
    if(procedimientoActual.equals("program")){
      // unicamente si el procedimiento actual es program, el scope de la variable es global
      scope = "global";    }
    auxArreglo.setScope(scope);

	// dar de alta la variable en el directorio de variables del procedimiento actual
    if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(auxArreglo)){
	  // si ya existe una variable con ese nombre, reportar error
      errorHandler(2,nombreArreglo.toString());    }  }  
   <CORIZQ > <CTEI > <CORDER > [<IGUAL > defarr()]
}


void func():
{int tipoFuncion; Token nombreProc;}
{
 < FUNC > {
   // crear un objeto procedimiento
   Procedimiento procAux = new Procedimiento(); }
 tipoFuncion = func1() {
   // guardar el tipo de procedimiento
   procAux.setTipoProcedimiento(tipoFuncion); }
 nombreProc = < ID > {
   // guardar el nombre del procedimiento en el objeto
   procAux.setNombreProcedimiento(nombreProc.toString());

	// dar de alta el procedimiento en el directorio de procedimientos
   if (!dirProcedimientos.agregarProcedimiento(procAux)) {
     	  // reportar error si ya existe un procedimiento con este nombre
		  errorHandler(1, nombreProc.toString());
	} else{
	  // si se pudo guardar el procedimiento, asignar procedimientoActual con el id recien leido
   		procedimientoActual = nombreProc.toString();	}
 }
 <PARIZQ > param() < PARDER > body() {
   // borrar tabla de variables para el procedimiento actual
   dirProcedimientos.getProcedimientos().get(procedimientoActual).setVariables(null); }
 
}

int func1():
{int tipoFuncion;}
{
 tipoFuncion = tipo() {return tipoFuncion;}
 | < VOID > {return Codigos.VOID;}
}
 
void param():
{}
{
  [param1() (< COMA > param1())*]
}

void param1():
{int tipoParam; Token nombreParam;}
{
  tipoParam = tipo()  {
    // si el procedimiento actual no tiene ya un directorio de variables, crearlo
    if(dirProcedimientos.getProcedimientos().get(procedimientoActual).getVariables()==null){     dirProcedimientos.getProcedimientos().get(procedimientoActual).crearTablaDeVariables();
	}
	// crear objeto variable y guardar el tipo y scope
    Variable paramAux = new Variable();
    paramAux.setTipoVariable(tipoParam);
    paramAux.setScope("local");  }
   [< AMP >] nombreParam = <ID >   {
     // guardar el nombre del parametro en el objeto
     paramAux.setNombreVariable(nombreParam.toString());
	// dar de alta el parametro en el directorio de variables del procedimiento actual
     if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(paramAux)){		// reportar error si ya existe una variable con ese nombre
		errorHandler(3, nombreParam.toString());
     }   } 
}

void body():
{}
{
  < LLAIZQ > [vars()] (body1())* [<RETURN > exp() < PYC >] <LLADER >
}

void body1():
{}
{
  assignllam() | cond() | read() | write() | cycle()
}

void assign():
{}
{
  [<CORIZQ > exp() < CORDER >] <IGUAL > exp() < PYC > 
}

void exp():
{}
{
  e1() [(< AND > | < OR >) e1()]
}

void e1():
{}
{
  e2() [(< MENOR > | < MAYOR > | < MENORIG > | < MAYORIG > | < IGUALIG > | < DIFERENTE > ) e2()]
}

void e2():
{}
{
  term() ((< MAS > | < MENOS >) term())*
}

void term():
{}
{
  fact()  {
    // revisar si el tope es * o /
    if (pilaOperadores.peek()== Codigos.MULT || pilaOperadores.peek()== Codigos.DIV) {
		int operador = pilaOperadores.pop();
		int operando2 = pilaOperandos.pop();
		int operando1 = pilaOperandos.pop();
		int tipo2 = pilaTipos.pop();
		int tipo1 = pilaTipos.pop();
		// revisar si combinacion de tipos es permitida

		if(cuboSemantico.getCubo()[tipo1][tipo2][operador]!= Codigos.ERROR) {
		  // generar cuadruplo		} else {
		  // ERROR		}
		
    }         }
  ((< POR > {pilaOperadores.push(Codigos.MULT);}
  | < ENTRE >{pilaOperadores.push(Codigos.DIV);}) fact())*
}

void fact():
{}
{
  [<NEGACION >] (fact1() | fact2() | fact3())
}

void fact1():
{}
{
  cte()
}

void fact2():
{}
{
  < PARIZQ > exp() < PARDER >
}

void fact3():
{Token id;}
{
 id = < ID > {
   // buscar que exista el id
   Variable varActual = dirProcedimientos.obtenerVariable(procedimientoActual, id.toString()); 
   if ( varActual == null) {
     // ERROR   } else {
     // meter direccion y tipo a las pilas
     pilaOperandos.push(varActual.getDireccionVariable());
     pilaTipos.push(varActual.getTipoVariable());   }
    } [(fact4() | fact5())] 
}

void fact4():
{}
{
  < CORIZQ >
  {
    // meter a pila fondo falso
	pilaOperadores.push(Codigos.FONDOFALSO);     }
  exp() < CORDER >  {
    // sacar fondo falso
    pilaOperadores.pop();  }
}

void fact5():
{}
{
  < PARIZQ > exp() (< COMA > exp())* < PARDER >
}

void cond():
{}
{
  < IF > <PARIZQ > exp() < PARDER > body() (< ELIF > <PARIZQ > exp() < PARDER > body())* [<ELSE > body()]
}

void write():
{}
{
  < PRINT > <PARIZQ > exp() < PARDER > <PYC >
}

void read():
{}
{
  < READ > <PARIZQ > <ID > [<CORIZQ > exp() < CORDER >] < PARDER > <PYC >
}

void cycle():
{}
{
  < WHILE > <PARIZQ > exp() < PARDER > body()
}

void llam():
{}
{
   <PARIZQ > exp() (< COMA > exp())* < PARDER > <PYC >
}

void main():
{}
{
  < MAIN >  {
	// asignar procedimientoActual a main
	procedimientoActual ="main";
    // crear el procedimiento Main con nombre y tipo
    Procedimiento mainProc = new Procedimiento();
	mainProc.setNombreProcedimiento("main");
	mainProc.setTipoProcedimiento(Codigos.MAIN);

    // dar de alta el proc main en directorio de procedimientos
    dirProcedimientos.agregarProcedimiento(mainProc);  } <PARIZQ > < PARDER > body()
}

void assignllam():
{}
{
  < ID > (llam() | assign())
}