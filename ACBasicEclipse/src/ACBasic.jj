/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 * Autors: Angela Romo, Cesar Rodriguez
 */
options
{
  static = true;
}

PARSER_BEGIN(ACBasic)
import Data.*;
public class ACBasic
{
  private static DirectorioProcedimientos dirProcedimientos;
  private static String procedimientoActual;
  
  public static void main(String args []) throws ParseException {
    ACBasic parser = new ACBasic(System.in);

    System.out.println("Reading from standard input...");
    try
    {
     parser.prog();
     System.out.println("OK.");
     for (String keyActual: dirProcedimientos.getProcedimientos().keySet()){
          System.out.println("---------------------------");
          Procedimiento actual = dirProcedimientos.getProcedimientos().get(keyActual);
          System.out.print(actual.getNombreProcedimiento()+ ": ");
          System.out.println(actual.getTipoProcedimiento());
          for (String keyVariable : actual.getVariables().keySet()) {			Variable varActual = actual.getVariables().get(keyVariable);
			System.out.print(varActual.getNombreVariable() + ": ");
			System.out.println(varActual.getTipoVariable());
          }
      }
          
      } catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
      }
    }
  

  static void errorHandler(int type, String detail) {
    switch (type){
      case 1:
        System.out.println("Error: Procedimiento repetido:" + detail);
		System.exit(0);
      	break;
	  case 2:
        System.out.println("Error: Variable repetida:" + detail);
		System.exit(0);
      	break;
      case 3:
        System.out.println("Error: Parametro repetido:" + detail);
		System.exit(0);
      	break;
          }  }
  
}

PARSER_END(ACBasic)

SKIP : { " " | "\r" | "\t" | "\n" }
TOKEN: { < PROGRAM : "program" > }
TOKEN: { < VAR : "var" > }
TOKEN: { < FUNC : "func" > }
TOKEN: { < MAIN : "main" > }
TOKEN: { < VOID : "void" > }

TOKEN: { < INT : "int" > }
TOKEN: { < CHAR : "char" > }
TOKEN: { < FLOAT : "float" > }
TOKEN: { < BOOL : "bool" > }
TOKEN: { < STRING : "string" > }
TOKEN: { < ARRAY : "array" > }

TOKEN: { < PRINT : "print" > }
TOKEN: { < READ : "read" > }
TOKEN: { < WHILE : "while" > }
TOKEN: { < TRUE : "true" > }
TOKEN: { < FALSE : "false" > }
TOKEN: { < IF : "if" > }
TOKEN: { < ELIF : "elif" > }
TOKEN: { < ELSE : "else" > }

TOKEN: { < AMP : "&" > }
TOKEN: { < RETURN : "return" > }

TOKEN: { < PYC : ";" > }
TOKEN: { < COMA : "," > }


TOKEN: { < LLAIZQ : "{" > }
TOKEN: { < LLADER : "}" > }
TOKEN: { < CORIZQ : "[" > }
TOKEN: { < CORDER : "]" > }

TOKEN: { < IGUAL : "=" > }
TOKEN: { < PARIZQ : "(" > }
TOKEN: { < PARDER : ")" > }
TOKEN: { < MAYOR : ">" > }
TOKEN: { < MENOR : "<" > }
TOKEN: { < MENORIG : "<=" > }
TOKEN: { < MAYORIG : ">=" > }
TOKEN: { < IGUALIG : "==" > }
TOKEN: { < DIFERENTE : "!=" > }
TOKEN: { < NEGACION : "!" > }
TOKEN: { < AND : "&&" > }
TOKEN: { < OR : "||" > }

TOKEN: { < MAS : "+" > }
TOKEN: { < MENOS : "-" > }
TOKEN: { < POR : "*" > }
TOKEN: { < ENTRE : "/" > }

TOKEN: { < ID : < LETTER >(("_")? (< LETTER >|< DIGIT >))* > }
TOKEN: { < CTEI : (<DIGIT>)+> }
TOKEN: { < CTEF : (<DIGIT>)+ "." (<DIGIT>)+ > }
TOKEN: { < CTESTR : "\"" (< DIGIT >|< LETTER >| < CARACTER >)* "\"" > }
TOKEN: { < CTECHAR : "'" (< DIGIT >|< LETTER >| < CARACTER >)? "'" > }

TOKEN :
{
  <#DIGIT: ["0"-"9"]>
| <#LETTER: ["a"-"z", "A"-"Z"]>
| < #CARACTER : ["¡" , "!" , "@" , "#" , "$" , "%" , "&" , "/" , "\\" , "(" , ")" , "=" ,"¿" , "?" , "-" , "_"
	,"+" ,"*","{","}" ,"[" ,"]" ,":" ,";" ,"." ,"," ,">","<" ,"|" ," "]>
}


void prog() :
{Token idPrograma;}
{
  < PROGRAM >  {
    dirProcedimientos = new DirectorioProcedimientos();  }
   idPrograma =  <ID >
   {
     	// guardar el id del procedimiento actual
		procedimientoActual = idPrograma.toString();
		// crear un objeto procedimiento auxiliar para guardar info del procedimiento program
		Procedimiento programProc = new Procedimiento();
		programProc.setNombreProcedimiento(idPrograma.toString());
		programProc.setTipoProcedimiento("program");
		// guardar el procedimiento program en el directorio de procedimientos
		if (!dirProcedimientos.agregarProcedimiento(programProc)) {
		  errorHandler(1,idPrograma.toString());		}
   }
   <PYC > [vars()] (func())* main()
}

String tipo():
{}
{
  < INT > {return "int";}
  | < FLOAT > {return "float";}
  | < CHAR > {return "char";}
  | < STRING > {return "string";}
  | < BOOL > {return "bool";}
}

void cte():
{}
{
  < CTEI > | < CTEF > | < TRUE > | < FALSE > | < CTESTR > | < CTECHAR >
}

void defarr():
{}
{
  < CORIZQ > cte() (< COMA > cte())* < CORDER >
}

void vars():
{}
{
  < VAR >  {
    // crear tabla de variables para el procedimiento actual
    dirProcedimientos.getProcedimientos().get(procedimientoActual).crearTablaDeVariables();  }
   vars1() < PYC > (vars1() < PYC >)*
}

void vars1():
{}
{
  vars2() | vars3()
}

void vars2():
{String tipoVariable; Token nombreVariable;}
{
  tipoVariable = tipo() nombreVariable=< ID >
  {
    String scopeVar = "local";
    if (procedimientoActual.equals("program")) {      scopeVar = "global";
   	}
    Variable varAuxiliar = new Variable(nombreVariable.toString(), tipoVariable, scopeVar);
    if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(varAuxiliar)){
      errorHandler(2,nombreVariable.toString());    }  }[<IGUAL > cte()]
  (< COMA > nombreVariable=<ID >
	{
	    varAuxiliar = new Variable(nombreVariable.toString(), tipoVariable, scopeVar);
	    if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(varAuxiliar)) {
      		errorHandler(2,nombreVariable.toString());
    	}
    }
    [<IGUAL > cte()] )* 
}

void vars3():
{String tipoArreglo; Token nombreArreglo;}
{
  < ARRAY >
  {
    Variable auxArreglo = new Variable();
  }
  tipoArreglo = tipo()  {
    auxArreglo.setTipoVariable(tipoArreglo);  }
  nombreArreglo = < ID >
  {
    auxArreglo.setNombreVariable(nombreArreglo.toString());
    String scope = "local";
    if(procedimientoActual.equals("program")){
      scope = "global";    }
    auxArreglo.setScope(scope);

    if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(auxArreglo)){
      errorHandler(2,nombreArreglo.toString());    }  }  
   <CORIZQ > <CTEI > <CORDER > [<IGUAL > defarr()]
}


void func():
{String tipoFuncion; Token nombreProc;}
{
 < FUNC > {
   Procedimiento procAux = new Procedimiento(); }
 tipoFuncion = func1() {
   procAux.setTipoProcedimiento(tipoFuncion); }
 nombreProc = < ID > {
   procAux.setNombreProcedimiento(nombreProc.toString());

   if (!dirProcedimientos.agregarProcedimiento(procAux)) {
		  errorHandler(1, nombreProc.toString());
	} else{
   		procedimientoActual = nombreProc.toString();	}
 }
 <PARIZQ > param() < PARDER > body()
}

String func1():
{String tipoFuncion;}
{
 tipoFuncion = tipo() {return tipoFuncion;}
 | < VOID > {return "void";}
}
 
void param():
{}
{
  [param1() (< COMA > param1())*]
}

void param1():
{String tipoParam; Token nombreParam;}
{
  tipoParam = tipo()  {
    if(dirProcedimientos.getProcedimientos().get(procedimientoActual).getVariables()==null){     dirProcedimientos.getProcedimientos().get(procedimientoActual).crearTablaDeVariables();
	}
    Variable paramAux = new Variable();
    paramAux.setTipoVariable(tipoParam);
    paramAux.setScope("local");  }
   [< AMP >] nombreParam = <ID >   {
     paramAux.setNombreVariable(nombreParam.toString());

     if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(paramAux)){		errorHandler(3, nombreParam.toString());
     }   } 
}

void body():
{}
{
  < LLAIZQ > [vars()] (body1())* [<RETURN > exp() < PYC >] <LLADER >
}

void body1():
{}
{
  assignllam() | cond() | read() | write() | cycle()
}

void assign():
{}
{
  [<CORIZQ > exp() < CORDER >] <IGUAL > exp() < PYC > 
}

void exp():
{}
{
  e1() [(< AND > | < OR >) e1()]
}

void e1():
{}
{
  e2() [(< MENOR > | < MAYOR > | < MENORIG > | < MAYORIG > | < IGUALIG > | < DIFERENTE > ) e2()]
}

void e2():
{}
{
  term() ((< MAS > | < MENOS >) term())*
}

void term():
{}
{
  fact() ((< POR > | < ENTRE >) fact())*
}

void fact():
{}
{
  [<NEGACION >] (fact1() | fact2() | fact3())
}

void fact1():
{}
{
  cte()
}

void fact2():
{}
{
  < PARIZQ > exp() < PARDER >
}

void fact3():
{}
{
 < ID > [(fact4() | fact5())] 
}

void fact4():
{}
{
  < CORIZQ > exp() < CORDER >
}

void fact5():
{}
{
  < PARIZQ > exp() (< COMA > exp())* < PARDER >
}

void cond():
{}
{
  < IF > <PARIZQ > exp() < PARDER > body() (< ELIF > <PARIZQ > exp() < PARDER > body())* [<ELSE > body()]
}

void write():
{}
{
  < PRINT > <PARIZQ > exp() < PARDER > <PYC >
}

void read():
{}
{
  < READ > <PARIZQ > <ID > [<CORIZQ > exp() < CORDER >] < PARDER > <PYC >
}

void cycle():
{}
{
  < WHILE > <PARIZQ > exp() < PARDER > body()
}

void llam():
{}
{
   <PARIZQ > exp() (< COMA > exp())* < PARDER > <PYC >
}

void main():
{}
{
  < MAIN > <PARIZQ > < PARDER > body()
}

void assignllam():
{}
{
  < ID > (llam() | assign())
}